<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1protocol.html">protocol</a></li><li class="navelem"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1protocol_1_1MsgIdLayer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="MsgIdLayer_8h_source.html">comms/protocol/MsgIdLayer.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TField, typename TMessage, typename TAllMessages, typename TNextLayer, typename... TOptions&gt;<br />
class comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;</h3>

<p>Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by other (next) layers. </p>
<p>The main purpose of this layer is to process the message ID information. Holds instance of <a class="el" href="classcomms_1_1MsgFactory.html" title="Message factory class. ">comms::MsgFactory</a> as its private member and uses it to create message(s) with the required ID. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TField</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">Field</a> type that contains message ID. </td></tr>
    <tr><td class="paramname">TMessage</td><td>Interface class for the <b>input</b> messages </td></tr>
    <tr><td class="paramname">TAllMessages</td><td>Types of all <b>input</b> messages, bundled in std::tuple, that this protocol stack must be able to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence. ">read()</a> as well as create (using <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a96cd09fb8c2b96fcffdfbad758c0fd59" title="Create message object given the ID. ">createMsg()</a>). </td></tr>
    <tr><td class="paramname">TNextLayer</td><td>Next transport layer type. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Default functionality extension options. Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ExtendingClass.html">comms::option::def::ExtendingClass</a> - Use this option to provide a class name of the extending class, which can be used to extend existing functionality. See also <a class="el" href="page_custom_id_layer.html">Defining Custom Message ID Protocol Stack Layer</a> tutorial page. </li>
<li>All the options supported by the <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>. All the options except ones listed above will be forwarded to the definition of the inner instance of <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1protocol_1_1MsgIdLayer.png" usemap="#comms::protocol::MsgIdLayer_3C_20TField_2C_20TMessage_2C_20TAllMessages_2C_20TNextLayer_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::protocol::MsgIdLayer_3C_20TField_2C_20TMessage_2C_20TAllMessages_2C_20TNextLayer_2C_20TOptions_20_3E_map" name="comms::protocol::MsgIdLayer_3C_20TField_2C_20TMessage_2C_20TAllMessages_2C_20TNextLayer_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" alt="comms::protocol::ProtocolLayerBase&lt; TField, TNextLayer, details::ProtocolLayerExtendingClassT&lt; MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions... &gt;, details::MsgIdLayerOptionsParser&lt; TOptions... &gt; &gt; &gt;" shape="rect" coords="0,0,1308,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a81910431d8e60b60e94a91fc9c8d5a6a"><td class="memItemLeft" align="right" valign="top"><a id="a81910431d8e60b60e94a91fc9c8d5a6a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a81910431d8e60b60e94a91fc9c8d5a6a">ParsedOptions</a> = ParsedOptionsInternal</td></tr>
<tr class="memdesc:a81910431d8e60b60e94a91fc9c8d5a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options. <br /></td></tr>
<tr class="separator:a81910431d8e60b60e94a91fc9c8d5a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cadbaa7153c38f7e7e4fd510210cdf3"><td class="memItemLeft" align="right" valign="top"><a id="a7cadbaa7153c38f7e7e4fd510210cdf3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7cadbaa7153c38f7e7e4fd510210cdf3">FactoryParsedOptions</a> = typename <a class="el" href="classcomms_1_1MsgFactory.html#a610d36f974687e689c1bf3e3a0339eea">Factory::ParsedOptions</a></td></tr>
<tr class="memdesc:a7cadbaa7153c38f7e7e4fd510210cdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options of the message Factory. <br /></td></tr>
<tr class="separator:a7cadbaa7153c38f7e7e4fd510210cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4cd9170885c25609445735d285c80d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#afa4cd9170885c25609445735d285c80d">AllMessages</a> = typename <a class="el" href="classcomms_1_1MsgFactory.html#a9bfccfddae66f917b11dc8ca05128402">Factory::AllMessages</a></td></tr>
<tr class="memdesc:afa4cd9170885c25609445735d285c80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported message types bundled in std::tuple.  <a href="#afa4cd9170885c25609445735d285c80d">More...</a><br /></td></tr>
<tr class="separator:afa4cd9170885c25609445735d285c80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561d5da49f0e700cdc109b68b9a30b3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a561d5da49f0e700cdc109b68b9a30b3a">MsgPtr</a> = typename <a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">Factory::MsgPtr</a></td></tr>
<tr class="memdesc:a561d5da49f0e700cdc109b68b9a30b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of smart pointer that will hold allocated message object.  <a href="#a561d5da49f0e700cdc109b68b9a30b3a">More...</a><br /></td></tr>
<tr class="separator:a561d5da49f0e700cdc109b68b9a30b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b70fe3164c7dc2dcb7223d7fcffcf"><td class="memItemLeft" align="right" valign="top"><a id="a620b70fe3164c7dc2dcb7223d7fcffcf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a620b70fe3164c7dc2dcb7223d7fcffcf">Message</a> = TMessage</td></tr>
<tr class="memdesc:a620b70fe3164c7dc2dcb7223d7fcffcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the <b>input</b> message interface. <br /></td></tr>
<tr class="separator:a620b70fe3164c7dc2dcb7223d7fcffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1ea3bdff923c98bf4687ed8b3f2c74"><td class="memItemLeft" align="right" valign="top"><a id="a5e1ea3bdff923c98bf4687ed8b3f2c74"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5e1ea3bdff923c98bf4687ed8b3f2c74">MsgIdType</a> = typename <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">Message::MsgIdType</a></td></tr>
<tr class="memdesc:a5e1ea3bdff923c98bf4687ed8b3f2c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message ID. <br /></td></tr>
<tr class="separator:a5e1ea3bdff923c98bf4687ed8b3f2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f0776807632af96afcee3fac19a910"><td class="memItemLeft" align="right" valign="top"><a id="a08f0776807632af96afcee3fac19a910"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a> = typename <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">Message::MsgIdParamType</a></td></tr>
<tr class="memdesc:a08f0776807632af96afcee3fac19a910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message ID when passed by the parameter. <br /></td></tr>
<tr class="separator:a08f0776807632af96afcee3fac19a910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b32cf672476ce4dbb77d1529a064b"><td class="memItemLeft" align="right" valign="top"><a id="ac32b32cf672476ce4dbb77d1529a064b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> = typename <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">BaseImpl::Field</a></td></tr>
<tr class="memdesc:ac32b32cf672476ce4dbb77d1529a064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field object used to read/write message ID value. <br /></td></tr>
<tr class="separator:ac32b32cf672476ce4dbb77d1529a064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4182e28d234204d51580d38f0ccdd3"><td class="memItemLeft" align="right" valign="top"><a id="a5b4182e28d234204d51580d38f0ccdd3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5b4182e28d234204d51580d38f0ccdd3">CreateFailureReason</a> = typename <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fe">Factory::CreateFailureReason</a></td></tr>
<tr class="memdesc:a5b4182e28d234204d51580d38f0ccdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reason for message creation failure. <br /></td></tr>
<tr class="separator:a5b4182e28d234204d51580d38f0ccdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a917e203e5507fb488191deba16f8e5e8"><td class="memItemLeft" align="right" valign="top"><a id="a917e203e5507fb488191deba16f8e5e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a917e203e5507fb488191deba16f8e5e8">MsgIdLayer</a> ()=default</td></tr>
<tr class="memdesc:a917e203e5507fb488191deba16f8e5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a917e203e5507fb488191deba16f8e5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ea4ede865aea5089370fa34fe0381f"><td class="memItemLeft" align="right" valign="top"><a id="ab0ea4ede865aea5089370fa34fe0381f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ab0ea4ede865aea5089370fa34fe0381f">MsgIdLayer</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:ab0ea4ede865aea5089370fa34fe0381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ab0ea4ede865aea5089370fa34fe0381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df4fd1b818d780b4e0c7589aa01ea30"><td class="memItemLeft" align="right" valign="top"><a id="a4df4fd1b818d780b4e0c7589aa01ea30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a4df4fd1b818d780b4e0c7589aa01ea30">MsgIdLayer</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a4df4fd1b818d780b4e0c7589aa01ea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a4df4fd1b818d780b4e0c7589aa01ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b077b5269046534ce1f95bf2acbc839"><td class="memItemLeft" align="right" valign="top"><a id="a2b077b5269046534ce1f95bf2acbc839"></a>
<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a2b077b5269046534ce1f95bf2acbc839">operator=</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:a2b077b5269046534ce1f95bf2acbc839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:a2b077b5269046534ce1f95bf2acbc839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5854c66a744967a34b262047530892"><td class="memItemLeft" align="right" valign="top"><a id="a8d5854c66a744967a34b262047530892"></a>
<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a8d5854c66a744967a34b262047530892">operator=</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a8d5854c66a744967a34b262047530892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a8d5854c66a744967a34b262047530892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39b3c689a1c446239879f77f7e885b"><td class="memItemLeft" align="right" valign="top"><a id="a5e39b3c689a1c446239879f77f7e885b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5e39b3c689a1c446239879f77f7e885b">~MsgIdLayer</a> () noexcept=default</td></tr>
<tr class="memdesc:a5e39b3c689a1c446239879f77f7e885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a5e39b3c689a1c446239879f77f7e885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00d71aa57799789befc68189f7f718f"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:af00d71aa57799789befc68189f7f718f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f">doRead</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:af00d71aa57799789befc68189f7f718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized read functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>.  <a href="#af00d71aa57799789befc68189f7f718f">More...</a><br /></td></tr>
<tr class="separator:af00d71aa57799789befc68189f7f718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d804fa610375e1379c43549d1b20981"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </td></tr>
<tr class="memitem:a7d804fa610375e1379c43549d1b20981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7d804fa610375e1379c43549d1b20981">doWrite</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</td></tr>
<tr class="memdesc:a7d804fa610375e1379c43549d1b20981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized write functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>.  <a href="#a7d804fa610375e1379c43549d1b20981">More...</a><br /></td></tr>
<tr class="separator:a7d804fa610375e1379c43549d1b20981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cd09fb8c2b96fcffdfbad758c0fd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a561d5da49f0e700cdc109b68b9a30b3a">MsgPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a96cd09fb8c2b96fcffdfbad758c0fd59">createMsg</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a> id, unsigned idx=0, <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5b4182e28d234204d51580d38f0ccdd3">CreateFailureReason</a> *reason=nullptr)</td></tr>
<tr class="memdesc:a96cd09fb8c2b96fcffdfbad758c0fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.  <a href="#a96cd09fb8c2b96fcffdfbad758c0fd59">More...</a><br /></td></tr>
<tr class="separator:a96cd09fb8c2b96fcffdfbad758c0fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7e4de47b7529fd1e3abfd48e79d5a111"><td class="memItemLeft" align="right" valign="top"><a id="a7e4de47b7529fd1e3abfd48e79d5a111"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7e4de47b7529fd1e3abfd48e79d5a111">isDispatchPolymorphic</a> ()</td></tr>
<tr class="memdesc:a7e4de47b7529fd1e3abfd48e79d5a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether polymorphic dispatch tables are generated internally to map message ID to actual type. <br /></td></tr>
<tr class="separator:a7e4de47b7529fd1e3abfd48e79d5a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733590a98d0ba765703c8552bd736c78"><td class="memItemLeft" align="right" valign="top"><a id="a733590a98d0ba765703c8552bd736c78"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a733590a98d0ba765703c8552bd736c78">isDispatchStaticBinSearch</a> ()</td></tr>
<tr class="memdesc:a733590a98d0ba765703c8552bd736c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether static binary search dispatch is generated internally to map message ID to actual type. <br /></td></tr>
<tr class="separator:a733590a98d0ba765703c8552bd736c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add556798c4254b8307a8934b74425663"><td class="memItemLeft" align="right" valign="top"><a id="add556798c4254b8307a8934b74425663"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#add556798c4254b8307a8934b74425663">isDispatchLinearSwitch</a> ()</td></tr>
<tr class="memdesc:add556798c4254b8307a8934b74425663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether linear switch dispatch is generated internally to map message ID to actual type. <br /></td></tr>
<tr class="separator:add556798c4254b8307a8934b74425663"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a04ff4a01821751edbf49a568d6b56f47"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5e1ea3bdff923c98bf4687ed8b3f2c74">MsgIdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a04ff4a01821751edbf49a568d6b56f47">getMsgIdFromField</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field)</td></tr>
<tr class="memdesc:a04ff4a01821751edbf49a568d6b56f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve message id from the field.  <a href="#a04ff4a01821751edbf49a568d6b56f47">More...</a><br /></td></tr>
<tr class="separator:a04ff4a01821751edbf49a568d6b56f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53d12505a533c7ad4d2741381beec06"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ab53d12505a533c7ad4d2741381beec06"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ab53d12505a533c7ad4d2741381beec06">beforeRead</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TMsg &amp;msg)</td></tr>
<tr class="memdesc:ab53d12505a533c7ad4d2741381beec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra operation before read.  <a href="#ab53d12505a533c7ad4d2741381beec06">More...</a><br /></td></tr>
<tr class="separator:ab53d12505a533c7ad4d2741381beec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0054511435ae10d307f05b458b3420a1"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a0054511435ae10d307f05b458b3420a1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a0054511435ae10d307f05b458b3420a1">prepareFieldForWrite</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a> id, const TMsg &amp;msg, <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field)</td></tr>
<tr class="memdesc:a0054511435ae10d307f05b458b3420a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare field for writing.  <a href="#a0054511435ae10d307f05b458b3420a1">More...</a><br /></td></tr>
<tr class="separator:a0054511435ae10d307f05b458b3420a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8f1fd3aa724abaf48ab9636acb88742e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f1fd3aa724abaf48ab9636acb88742e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a8f1fd3aa724abaf48ab9636acb88742e">isMsgIdLayer</a> ()</td></tr>
<tr class="memdesc:a8f1fd3aa724abaf48ab9636acb88742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the provided type is a variant of <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a>.  <a href="#a8f1fd3aa724abaf48ab9636acb88742e">More...</a><br /></td></tr>
<tr class="separator:a8f1fd3aa724abaf48ab9636acb88742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afa4cd9170885c25609445735d285c80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4cd9170885c25609445735d285c80d">&#9670;&nbsp;</a></span>AllMessages</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#afa4cd9170885c25609445735d285c80d">AllMessages</a> =  typename <a class="el" href="classcomms_1_1MsgFactory.html#a9bfccfddae66f917b11dc8ca05128402">Factory::AllMessages</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All supported message types bundled in std::tuple. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MsgFactory.html#a9bfccfddae66f917b11dc8ca05128402" title="All messages provided as template parameter to this class. ">comms::MsgFactory::AllMessages</a>. </dd></dl>

</div>
</div>
<a id="a561d5da49f0e700cdc109b68b9a30b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561d5da49f0e700cdc109b68b9a30b3a">&#9670;&nbsp;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a561d5da49f0e700cdc109b68b9a30b3a">MsgPtr</a> =  typename <a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">Factory::MsgPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of smart pointer that will hold allocated message object. </p>
<p>Same as <a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7" title="Smart pointer to Message which holds allocated message object. ">comms::MsgFactory::MsgPtr</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab53d12505a533c7ad4d2741381beec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53d12505a533c7ad4d2741381beec06">&#9670;&nbsp;</a></span>beforeRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::beforeRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extra operation before read. </p>
<p>Function called after appropriate message object has been created and before read operation is forwared to inner layer. <br />
 Default implementation does nothing, may be overriden in the derived class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">Field</a> of the layer that was successfully read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to message object, either interface class or message object itself (depending on how <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f" title="Customized read functionality, invoked by read(). ">doRead()</a> was invoked). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96cd09fb8c2b96fcffdfbad758c0fd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cd09fb8c2b96fcffdfbad758c0fd59">&#9670;&nbsp;</a></span>createMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a561d5da49f0e700cdc109b68b9a30b3a">MsgPtr</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5b4182e28d234204d51580d38f0ccdd3">CreateFailureReason</a> *&#160;</td>
          <td class="paramname"><em>reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create message object given the ID. </p>
<p>Hides and overrides <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a96cd09fb8c2b96fcffdfbad758c0fd59" title="Create message object given the ID. ">createMsg()</a> function inherited from <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a>. This function forwards the request to the message factory object (<a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>) embedded as a private data member of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reason</td><td>Failure reason in case creation has failed. May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to the created message object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MsgFactory.html#a5b1ad877b2b4c26ed0e64675e0b245d3" title="Create message object given the ID of the message. ">comms::MsgFactory::createMsg()</a> </dd></dl>

</div>
</div>
<a id="af00d71aa57799789befc68189f7f718f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00d71aa57799789befc68189f7f718f">&#9670;&nbsp;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerReader &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized read functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p>
<p>The function will read message ID from the data sequence first, generate appropriate (or validate provided) message object based on the read ID and forward the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence. ">read()</a> request to the next layer. If the message object cannot be generated (the message type is not provided inside <b>TAllMessages</b> template parameter), but the <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> option has beed used, the <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> may be generated instead.<br />
 <b>NOTE</b>, that <b>msg</b> parameter can be either reference to a smart pointer, which will hold allocated object, or to previously allocated object itself. In case of the latter, the function will compare read and expected message ID value and will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab">comms::ErrorStatus::InvalidMsgId</a> in case of mismatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
    <tr><td class="paramname">TNextLayerReader</td><td>next layer reader object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">Field</a> object to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer that will hold allocated message object, or to the previously allocated message object itself (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerReader</td><td>Reader object, needs to be invoked to forward read operation to the next layer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic extra output parameters passed to the "read" operatation of the protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a>). Need to passed on as variadic arguments to the <b>nextLayerReader</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><b>msg</b> parameter, in case of being a smart pointer, doesn't point to any object: <div class="fragment"><div class="line">assert(!msg); </div></div><!-- fragment --> </dd>
<dd>
Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation. ">comms::ErrorStatus::Success</a> if and only if msg points to a valid object (in case of being a smart pointer). </dd></dl>

</div>
</div>
<a id="a7d804fa610375e1379c43549d1b20981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d804fa610375e1379c43549d1b20981">&#9670;&nbsp;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerWriter &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized write functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p>
<p>The function will write ID of the message to the data sequence, then call <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence. ">write()</a> member function of the next protocol layer. If <b>TMsg</b> type is recognised to be actual message type (inherited from <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a> while using <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option to specify its numeric ID), its defined <b>doGetId()</b> member function (see <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5" title="Default implementation of ID retrieval functionality. ">comms::MessageBase::doGetId()</a>) non virtual function is called. Otherwise polymorphic <b>getId()</b> member function is used to retrieve the message ID information, which means the message interface class must use <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option to define appropriate interface. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer writer object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">Field</a> object to update and write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerWriter</td><td>Next layer writer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="a04ff4a01821751edbf49a568d6b56f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ff4a01821751edbf49a568d6b56f47">&#9670;&nbsp;</a></span>getMsgIdFromField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5e1ea3bdff923c98bf4687ed8b3f2c74">MsgIdType</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::getMsgIdFromField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve message id from the field. </p>
<p>May be overridden by the extending class </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">Field</a> for this layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0054511435ae10d307f05b458b3420a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0054511435ae10d307f05b458b3420a1">&#9670;&nbsp;</a></span>prepareFieldForWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::prepareFieldForWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare field for writing. </p>
<p>Must assign provided id value. May be overridden by the extending class if some complex functionality is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object being written </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">Field</a>, value of which needs to be populated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8f1fd3aa724abaf48ab9636acb88742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1fd3aa724abaf48ab9636acb88742e">&#9670;&nbsp;</a></span>isMsgIdLayer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool isMsgIdLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check of whether the provided type is a variant of <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/protocol/<a class="el" href="MsgIdLayer_8h_source.html">MsgIdLayer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 6 2019 16:13:38 for COMMS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
